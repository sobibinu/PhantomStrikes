import logging
import threading
import time
import re
from datetime import datetime
from scan_engine import ScanEngine
from deepai_integration import DeepAIIntegration
from models import ScanResult, Vulnerability
from app import db, create_app
import os
from flask import current_app

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self, target_url, scan_type="light", user_id=None):
        self.target_url = target_url
        self.scan_type = scan_type
        self.user_id = user_id
        self.scan_result = None
        self.scan_thread = None
        
    def start_scan(self, scan_config=None):
        """Start a new vulnerability scan."""
        # Create scan record in database
        self.scan_result = ScanResult(
            user_id=self.user_id,
            target_url=self.target_url,
            scan_type=self.scan_type,
            start_time=datetime.utcnow(),
            status="running",
            scan_config=str(scan_config) if scan_config else None
        )
        
        db.session.add(self.scan_result)
        db.session.commit()
        
        # Start scan in a separate thread
        self.scan_thread = threading.Thread(target=self._run_scan)
        self.scan_thread.daemon = True
        self.scan_thread.start()
        
        return self.scan_result.id
    
    def _run_scan(self):
        """Run the vulnerability scan in a background thread."""
        # Create a Flask app context for this thread
        app = create_app()
        
        with app.app_context():
            try:
                # Fetch the scan result from the database in this context
                scan_result = ScanResult.query.get(self.scan_result.id)
                if not scan_result:
                    logger.error(f"Scan result {self.scan_result.id} not found in database")
                    return
                
                # Initialize scan engine
                scan_engine = ScanEngine(self.target_url, self.scan_type, scan_result)
                
                # Run the scan
                success, message = scan_engine.run_scan()
                
                if not success:
                    logger.error(f"Scan failed: {message}")
                    scan_result.status = "failed"
                    db.session.commit()
                    return
                
                # Get scan vulnerabilities
                vulnerabilities = scan_engine.vulnerabilities
                
                # Save vulnerabilities to database
                severity_counts = {"high": 0, "medium": 0, "low": 0}
                
                for vulnerability in vulnerabilities:
                    db.session.add(vulnerability)
                    severity = vulnerability.severity.lower()
                    if severity in severity_counts:
                        severity_counts[severity] += 1
                
                # If authenticated scan, process with DeepAI for remediation suggestions
                if self.user_id is not None:
                    deepai = DeepAIIntegration()
                    for vulnerability in vulnerabilities:
                        # Only process if no remediation code already exists
                        if not vulnerability.remediation_code or len(vulnerability.remediation_code) < 10:
                            try:
                                remediation = deepai.get_remediation_suggestion(
                                    vulnerability.vulnerability_type,
                                    vulnerability.description,
                                    vulnerability.evidence
                                )
                                
                                if remediation:
                                    vulnerability.remediation = remediation.get('explanation', vulnerability.remediation)
                                    vulnerability.remediation_code = remediation.get('code', vulnerability.remediation_code)
                                    db.session.add(vulnerability)
                            except Exception as e:
                                logger.error(f"DeepAI integration error: {str(e)}")
                
                # Update scan result
                scan_result.end_time = datetime.utcnow()
                scan_result.status = "completed"
                scan_result.total_vulnerabilities = len(vulnerabilities)
                scan_result.high_severity = severity_counts.get("high", 0)
                scan_result.medium_severity = severity_counts.get("medium", 0)
                scan_result.low_severity = severity_counts.get("low", 0)
                
                db.session.commit()
                logger.info(f"Completed scan {scan_result.id} with {len(vulnerabilities)} vulnerabilities")
                
            except Exception as e:
                logger.exception(f"Error in scan thread: {str(e)}")
                try:
                    scan_result = ScanResult.query.get(self.scan_result.id)
                    if scan_result:
                        scan_result.status = "failed"
                        scan_result.end_time = datetime.utcnow()
                        db.session.commit()
                except Exception as inner_e:
                    logger.exception(f"Error updating scan status after failure: {str(inner_e)}")
    
    def get_scan_status(self):
        """Get the current status of an ongoing scan."""
        if not self.scan_result:
            return None
        
        return {
            'id': self.scan_result.id,
            'status': self.scan_result.status,
            'target_url': self.scan_result.target_url,
            'start_time': self.scan_result.start_time.isoformat() if self.scan_result.start_time else None,
            'end_time': self.scan_result.end_time.isoformat() if self.scan_result.end_time else None,
            'total_vulnerabilities': self.scan_result.total_vulnerabilities,
            'high_severity': self.scan_result.high_severity,
            'medium_severity': self.scan_result.medium_severity,
            'low_severity': self.scan_result.low_severity,
        }
    
    def stop_scan(self):
        """Stop an ongoing scan."""
        if self.scan_thread and self.scan_thread.is_alive():
            # Signal the scan engine to stop
            # This requires the scan engine to check the stop_scan flag
            if hasattr(self, 'scan_engine') and hasattr(self.scan_engine, 'stop_scan'):
                self.scan_engine.stop_scan.set()
            
            # Create app context and update the scan result status
            app = create_app()
            with app.app_context():
                # Get fresh instance from db
                scan_result = ScanResult.query.get(self.scan_result.id)
                if scan_result:
                    scan_result.status = "cancelled"
                    scan_result.end_time = datetime.utcnow()
                    db.session.commit()
                    return True
        
        return False

def get_scan_result(scan_id, is_authenticated=False):
    """Get a scan result from the database."""
    # Check if we're already in an app context
    try:
        from flask import current_app
        # If we get here without error, we're in an app context
        scan_result = ScanResult.query.get(scan_id)
    except RuntimeError:
        # Create an app context if needed
        app = create_app()
        with app.app_context():
            scan_result = ScanResult.query.get(scan_id)
            if not scan_result:
                return None
                
            # Process within the context and return the result
            return _process_scan_result(scan_result, is_authenticated)
    
    # Handle the case where we were already in an app context
    if not scan_result:
        return None
        
    return _process_scan_result(scan_result, is_authenticated)

def _process_scan_result(scan_result, is_authenticated=False):
    """Helper function to process a scan result object into a dictionary."""
    # If the user is not authenticated, provide limited information
    if not is_authenticated and scan_result.user_id is not None:
        # Return only summary statistics for authenticated users' scans
        return {
            'id': scan_result.id,
            'target_url': scan_result.target_url,
            'scan_type': scan_result.scan_type,
            'status': scan_result.status,
            'total_vulnerabilities': scan_result.total_vulnerabilities,
            'high_severity': scan_result.high_severity,
            'medium_severity': scan_result.medium_severity,
            'low_severity': scan_result.low_severity
        }
    
    # Return full details for authenticated users or guest scans
    result = {
        'id': scan_result.id,
        'target_url': scan_result.target_url,
        'scan_type': scan_result.scan_type,
        'start_time': scan_result.start_time.isoformat() if scan_result.start_time else None,
        'end_time': scan_result.end_time.isoformat() if scan_result.end_time else None,
        'status': scan_result.status,
        'total_vulnerabilities': scan_result.total_vulnerabilities,
        'high_severity': scan_result.high_severity,
        'medium_severity': scan_result.medium_severity,
        'low_severity': scan_result.low_severity,
        'vulnerabilities': []
    }
    
    # Include full vulnerability details for authenticated users
    if is_authenticated or scan_result.user_id is None:
        for vuln in scan_result.vulnerabilities:
            result['vulnerabilities'].append({
                'id': vuln.id,
                'vulnerability_type': vuln.vulnerability_type,
                'description': vuln.description,
                'location': vuln.location,
                'severity': vuln.severity,
                'evidence': vuln.evidence,
                'remediation': vuln.remediation,
                'remediation_code': vuln.remediation_code,
                'timestamp': vuln.timestamp.isoformat() if vuln.timestamp else None
            })
    
    return result

def get_scan_results_for_user(user_id, limit=10):
    """Get scan results for a specific user."""
    # Check if we're already in an app context
    try:
        from flask import current_app
        # If we get here without error, we're in an app context
        return _get_scan_results_for_user_helper(user_id, limit)
    except RuntimeError:
        # Create an app context if needed
        app = create_app()
        with app.app_context():
            return _get_scan_results_for_user_helper(user_id, limit)

def _get_scan_results_for_user_helper(user_id, limit=10):
    """Helper function to get scan results for a specific user."""
    scan_results = ScanResult.query.filter_by(user_id=user_id).order_by(ScanResult.start_time.desc()).limit(limit).all()
    
    results = []
    for scan in scan_results:
        results.append({
            'id': scan.id,
            'target_url': scan.target_url,
            'scan_type': scan.scan_type,
            'start_time': scan.start_time.isoformat() if scan.start_time else None,
            'end_time': scan.end_time.isoformat() if scan.end_time else None,
            'status': scan.status,
            'total_vulnerabilities': scan.total_vulnerabilities,
            'high_severity': scan.high_severity,
            'medium_severity': scan.medium_severity,
            'low_severity': scan.low_severity
        })
    
    return results

def get_guest_scans(limit=5):
    """Get recent guest scans."""
    # Check if we're already in an app context
    try:
        from flask import current_app
        # If we get here without error, we're in an app context
        return _get_guest_scans_helper(limit)
    except RuntimeError:
        # Create an app context if needed
        app = create_app()
        with app.app_context():
            return _get_guest_scans_helper(limit)

def _get_guest_scans_helper(limit=5):
    """Helper function to get recent guest scans."""
    scan_results = ScanResult.query.filter_by(user_id=None).order_by(ScanResult.start_time.desc()).limit(limit).all()
    
    results = []
    for scan in scan_results:
        results.append({
            'id': scan.id,
            'target_url': scan.target_url,
            'scan_type': 'light',  # Guest scans are always light
            'status': scan.status,
            'total_vulnerabilities': scan.total_vulnerabilities,
            'high_severity': scan.high_severity,
            'medium_severity': scan.medium_severity,
            'low_severity': scan.low_severity
        })
    
    return results

def sanitize_target_url(url):
    """Sanitize and validate target URL."""
    # Ensure URL has a scheme
    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url
    
    # Basic URL validation using regex
    url_pattern = re.compile(
        r'^(?:http|https)://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ipv4
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    
    if not url_pattern.match(url):
        raise ValueError("Invalid URL format")
    
    return url
